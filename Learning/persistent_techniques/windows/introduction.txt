| Technique                  | Description                                                               | When It Runs                               | Admin Needed?                       | UI / Visibility                          | Notes                                                                                  |
| -------------------------- | ------------------------------------------------------------------------- | ------------------------------------------ | ----------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------------------- |
| **WMI Event Subscription** | Sets up event-based script trigger using WMI. Lives in memory & registry. | On system events (e.g., login, USB insert) | âœ… Yes                               | âŒ No GUI, runs silently                  | Extremely stealthy. Lives until reboot (unless permanent class). Can be used for RATs. |
| **DLL Hijacking**          | Drop a malicious DLL where a legitimate app expects one.                  | When app is launched                       | âœ… Yes (to write in protected paths) | âŒ No visible window unless DLL shows one | Requires target app with unquoted DLL search path. Classic red team method.            |
| **Service Registry Abuse** | Modify `ImagePath` or `ServiceDLL` of an existing service.                | At service start                           | âœ… Yes                               | Depends on payload                       | If service auto-starts, payload runs at boot. Widely used in malware persistence.      |
| **Startup Folder Drop**    | Drop `.lnk` or `.exe` into userâ€™s `Startup` folder.                       | After user login                           | âŒ No                                | âœ… Visible app if GUI used                | Easy, but noisy. Limited to user-level persistence.                                    |
| **Token Impersonation**    | Exploit SeImpersonatePrivilege to run as higher user (e.g., SYSTEM).      | On exploit trigger                         | âŒ No (if privilege exists)          | âŒ Often invisible                        | Used by tools like JuicyPotato, PrintSpoofer. Abuses Windows token system.             |

**Introduction to Persistence Techniques (Windows & Linux)**

Persistence techniques are methods used by attackers (or even sysadmins writing automation) to ensure that a script, payload, or binary remains active or re-executes even after a system reboot or user logout. In red teaming and malware operations, persistence is what gives your payload immortality. Let's break this down, ninja-style.

---

### 1. WMI Event Subscription (Windows Only)

**What it is:** A method of creating a hidden, trigger-based task using Windows Management Instrumentation (WMI). It listens for specific system events like logon, USB insertion, or time-based triggers.

**How it works:** You use `__EventFilter`, `CommandLineEventConsumer`, and `__FilterToConsumerBinding` in WMI to bind a script to a system event. It stores in the WMI repository (which isn't checked by Task Scheduler or startup folders).

**Real-World Use Case:** You set a script to run every time the user logs in. It executes silently, living only in WMI memory and registry.

**Persistence Strength:** Stealthy, fileless, difficult to detect without dedicated forensic tools.

**Linux Equivalent:** Using `udev` rules or D-Bus to trigger shell scripts.

---

### 2. DLL Hijacking (Windows)

**What it is:** Tricking a program into loading a malicious DLL (Dynamic Link Library) by exploiting the search order.

**How it works:** Many apps look for DLLs in local folders before checking system folders. If an app tries to load `missing.dll`, and youâ€™ve placed your malicious `missing.dll` in the app folder, it runs your code.

**Do You Need C++?** Ideally yes. You write the malicious DLL in C/C++ or Rust and export the expected functions the app is looking for.

**Use Case:** A legitimate app is installed in `C:\Program Files\CoolApp\`, and you drop `cool.dll` in that folder. The app unknowingly loads it and executes your code.

**Persistence Strength:** File-based, low visibility. Requires file system access.

**Linux Equivalent:** LD\_PRELOAD or hijacking `.so` libraries.

---

### 3. Service Registry Abuse (Windows)

**What it is:** Modifying service registry keys like `ImagePath` or `ServiceDLL` so that Windows executes your payload when the service starts.

**How it works:** You locate a service (preferably an auto-starting one), edit its registry entry so it points to your binary instead of the original executable or DLL.

**Use Case:** Replace the binary path for a broken or rarely-used service. On next reboot, your EXE runs with SYSTEM privileges.

**Persistence Strength:** Medium-high, admin-only.

**Linux Equivalent:** Systemd service file modification.

---

### 4. Startup Folder Persistence (Windows)

**What it is:** Dropping a `.lnk` (shortcut) or `.exe` file in the user's `Startup` folder.

**How it works:** Anything placed in `%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup` runs automatically after the user logs in.

**Use Case:** Drop `update.lnk` pointing to your payload. On next user login, it launches.

**Persistence Strength:** Noisy but effective. Easily visible to user.

**Linux Equivalent:** Placing `.desktop` files in `~/.config/autostart/`

---

### 5. Token Impersonation (SeImpersonatePrivilege)

**What it is:** Abusing tokens in Windows to elevate from a low-privileged account to SYSTEM.

**How it works:** Windows uses tokens to identify users. Some processes run as SYSTEM and allow impersonation. If your user has `SeImpersonatePrivilege`, you can impersonate SYSTEM using tools like `JuicyPotato` or `PrintSpoofer`.

**Use Case:** Youâ€™re a regular user but your context has impersonation rights (common in IIS). You use PrintSpoofer to spawn a SYSTEM shell.

**Persistence Strength:** Not persistence in itself, but powerful for privilege escalation and chaining with persistence.

**Linux Equivalent:** SUID binary abuse, sudo misconfiguration.

---

### Bonus: Linux Techniques

* **rc.local:** Append a script to `/etc/rc.local` for execution at boot.
* **crontab:** Schedule recurring execution with `@reboot`.
* **systemd:** Create `.service` files in `/etc/systemd/system`.
* **bash\_profile:** Modify `~/.bash_profile` to run a script on shell startup.
* **LD\_PRELOAD:** Inject `.so` libraries before legitimate ones.

---

In future sections, each of these will be expanded with code samples, detection methods, blue team countermeasures, and how attackers blend in to evade detection. But for now, this is your war map. Choose your battlefield wisely.

Excellent â€” letâ€™s unpack this topic like a red teamer, a sysadmin, and a detection engineer *all at once*. Weâ€™ll go section by section, giving you deep explanations, clear examples, and answers to your current questions:

---

## ðŸ”“ Privilege Escalation via Services â€“ Full Breakdown

---

### 1. **Writable Service Binary (PathName)**

> **If the service executable (the binary) is located in a directory where your user account has write access,** you can replace it with your own EXE and gain SYSTEM privileges when the service starts.

#### ðŸ”§ Example:

Imagine this service:

```powershell
Get-WmiObject Win32_Service | Where-Object { $_.Name -eq "VulnService" }
```

Returns:

```
PathName: C:\Program Files\VulnApp\svc.exe
StartName: LocalSystem
```

If you (low-priv user) have write access to `C:\Program Files\VulnApp\svc.exe`:

```powershell
Copy-Item "C:\Payloads\reverse.exe" "C:\Program Files\VulnApp\svc.exe" -Force
Start-Service VulnService
```

âœ… Result: **Your payload runs as SYSTEM**

ðŸ§  This works *even if* you can't change the service settings â€” only file write perms matter.

---

### 2. **Writable Registry Keys â†’ Hijack `ImagePath`**

> If you have permission to modify the service registry key, you can **change the path to the service executable** (ImagePath) to point to your own binary.

#### ðŸ”§ Steps:

1. Find service:

```powershell
Get-Service | Where-Object { $_.Status -eq "Stopped" }
```

2. View its registry path:

```powershell
"HKLM:\SYSTEM\CurrentControlSet\Services\$($svc.Name)"
```

3. Replace the binary:

```powershell
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Fax" `
  -Name "ImagePath" `
  -Value "C:\Users\Public\reverse.exe"
```

Then:

```powershell
Start-Service Fax
```

> ðŸ§¨ This is *dangerous* and **very stealthy** because many tools donâ€™t check service registry paths.

---

### 3. **Service is Stoppable + Restartable**

> Even if you **canâ€™t edit** the binary or registry, if the service **lets you stop and start it**, and the binary is already vulnerable (e.g., writable), **you still win**.

#### Example (PowerUp will flag this):

```powershell
(Get-WmiObject Win32_Service | Where { $_.Name -eq "PrinterHelper" }).StartName
```

If it runs as SYSTEM and the service is:

* Stop/start allowed
* Binary is writeable by `Users`

âœ… Replace EXE âžœ restart âžœ SYSTEM shell.

ðŸ§  Abuse comes from **what you can do to the binary or its directory**, not just the registry.

---

## ðŸ“Œ DLL-Based Service Hijack (Advanced)

### What is it?

Some services **donâ€™t execute an EXE**, but instead load a **DLL** from a defined path.

Registry path:

```
HKLM\SYSTEM\CurrentControlSet\Services\<Svc>\Parameters\ServiceDll
```

### Attack:

1. Find one (manually or using `Autoruns`):

```powershell
Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\AudioSrv\Parameters" | Select ServiceDll
```

2. Replace the DLL with your own malicious version
   OR
   Edit `ServiceDll` path to point to a DLL you control

3. Restart service:

```powershell
Restart-Service AudioSrv
```

âœ… Result: DLL gets loaded as SYSTEM

> ðŸ’£ This works just like EXE hijacking, but stealthier â€” **fewer tools monitor this path.**

---

## âš ï¸ `binPath=` Abuse with `sc.exe`

This is a **classic lateral move** or privilege escalation trick.

### What it does:

It sets the **service binary to run `cmd.exe /c payload.exe`** instead of its original file.

```cmd
sc.exe config VulnService binPath= "cmd.exe /c C:\temp\reverse.exe"
sc.exe start VulnService
```

âœ… SYSTEM shell via `reverse.exe`

> The `cmd.exe /c` allows any command to run â€” often used to **execute PowerShell one-liners, downloaders, or open calc.exe** to prove access.

ðŸ”’ Watch out: **Defenders log `binPath` changes if they're smart.**

---

## âš–ï¸ PowerShell `Set-Service` vs `sc.exe`

### Which should you learn?

| Feature                    | `Set-Service` | `sc.exe`     |
| -------------------------- | ------------- | ------------ |
| Built into PowerShell      | âœ…             | âŒ (external) |
| Modify StartupType         | âœ…             | âœ…            |
| Modify ImagePath           | âŒ             | âœ…            |
| Change Recovery Options    | âŒ             | âœ…            |
| Create/delete service      | âœ…             | âœ…            |
| Works even when PS blocked | âŒ             | âœ…            |

### Verdict:

âœ… **Learn both.**

* Use `Set-Service` for scripts and automation
* Use `sc.exe` for registry-level control and persistence tricks
* `sc.exe` is more powerful but **more suspicious if logged**

---

## ðŸ› ï¸ Tools for Enumerating Weak Services

### 1. **PowerUp.ps1**

```powershell
Invoke-AllChecks
```

* Finds:

  * Writable binaries
  * Writable service keys
  * Unquoted paths
  * Registry hijack vectors

---

### 2. **AccessChk.exe**

```cmd
accesschk.exe -uwcqv "Users" *
```

ðŸ” Breakdown:

* `-u`: user
* `-w`: only show writeable
* `-c`: container objects (services)
* `-qv`: quiet verbose
* `"Users"`: group to scan
* `*`: check all services

This checks **which services your current user can write to** or control.

---

### 3. **WinPEAS.exe**

* GUI/console tool that finds:

  * Service misconfigs
  * Permission issues
  * Path weaknesses
  * Hijackable locations

> ðŸ§  Always run WinPEAS and PowerUp together â€” they find different things.

---

## ðŸ§  You Asked About `Get-WmiObject`

Your current notes are good â€” hereâ€™s what youâ€™re missing:
