                                        WINDOWS SERVICES
                                    =======================
- Services in Windows are background processes managed by the Service Control Manager (SCM).  
- PowerShell lets you query, start, stop, configure, and monitor them — all with scriptable precision.


        KEY COMMANDS.
    ---------------------
| Task                  | Cmdlet                           |
|------------------------|---------------------------------|
| View all services      | Get-Service                     |
| View one service       | Get-Service -Name <name>        |
| Start a service        | Start-Service -Name <name>      |
| Stop a service         | Stop-Service -Name <name>       |
| Restart a service      | Restart-Service -Name <name>    |
| Change config          | Set-Service -Name <name> ...    |
| Create new service     | New-Service                     |
| Delete service         | ❌ Not native (use `sc.exe`)   |

- They can run as:
    > LocalSystem (almost god-mode SYSTEM)
    > NetworkService (low-priv, but network-focused)
    > LocalService (least privilege)

    | Account Type     | Description                               |
    | ---------------- | ----------------------------------------- |
    | `LocalSystem`    | High-privilege (almost god-mode SYSTEM)   |
    | `NetworkService` | Low-priv, but can authenticate to network |
    | `LocalService`   | Least privilege, no network creds         |
    | **Custom User**  | Often domain users in corp setups         |


    > You manage them with tools like:
        I. services.msc
        II. sc.exe
        III. PowerShell: New-Service, Set-Service, Start-Service, etc.
        IV. Get-WmiObject Win32_Service      # Full object output
        V. Get-CimInstance Win32_Service    # Modern version of above

        | Tool                                | Use                                                             |
        | ----------------------------------- | --------------------------------------------------------------- |
        | `services.msc`                      | GUI viewer and manager                                          |
        | `sc.exe`                            | Native service CLI (legacy but powerful)                        |
        | PowerShell Cmdlets                  | Full control: `Get-Service`, `Set-Service`, `New-Service`, etc. |
        | `Get-WmiObject` / `Get-CimInstance` | For deep info: path, user, state                                |


        WHY SERVICES MATTER IN PERSISTENCE
    -------------------------------------------
1. Start before user logs in
2. Can run with no UI
3. SYSTEM by default if misconfigured
4. Persist through reboots
5. Often overlooked unless you're actively hunting
6. Combine service abuse with valid signing certificates or LOLBins (e.g. rundll32) for stealthier execution.

        
        COMMON RED TEAM ABUSES (AND LEGIT USE CASES)
    ---------------------------------------------------
|   Technique                              |    Description                                                 |
|------------------------------------------|----------------------------------------------------------------|
|Install new service	                   | Drop EXE, register as service = stealthy boot persistence      |
|Hijack existing service	               | Change the ImagePath in registry to point to your binary       |
|Replace ServiceDLL	For DLL-based services | drop malicious DLL                                             |
|Set to autostart	StartType              | Auto means it starts with Windows                              |
|Abuse binPath=                            | to execute cmd.exe	Like: cmd.exe /c calc.exe to sneak execution|


            USAGE.
        ------------
1. Viewing Services.
    List all services with status.
        EG.
            Get-Service 

    Filter services by status.
        EG.
            Get-Service | Where-Object {$_.Status -eq "Running" }

    Show services details.
        EG.
            Get-Service -Name "wuauserv" | Format-List *

    Get all auto-start services.
        EG.
            Get-WmiObject -Class Win32_Service | Where-Object { $_.StartMode -eq "Auto" }


2. Start / Stop / Restart Services.
    Start a service.
        EG.
            Start-Service -Name "Spooler"

    Stop a service.
        EG.
            Stop-Service -Name "Spooler"

    Restart service (with wait)
        EG.
            Restart-Service -Name "wuauserv" -Force -ErrorAction Stop

    Wait for service to stop.
        EG.
            Stop-Service -Name "BITS"
            Get-Service -Name "BITS" | Where-Object { $_.Status -eq "Stopped" }


3. Modify service properties.
    Set service to manual start.
        EG.
            Set-Service -Name "wuauserv" -StartupType Manual

    Set to disabled.
        EG.
            Set-Service -Name "Spooler" -StartupType Disabled

    Set to auto start.
        EG.
            Set-Service -Name "Spooler" -StartupType Automatic


4. Create / Remove services.
    Create a new service (e.g. to persist script)
        EG.
            (you have a script at C:\Tools\my.exe)
            New-Service -Name "MyService" -BinaryPathName "C:\Tools\my.exe" -DisplayName "My Cool Service" -Description "Monitors internal health checks" -StartupType Automatic

    Remove a service using sc.exe 
        EG.
            sc.exe delete MyService # Reliable everywhere.
            Remove-Service -Name "SysHealthMonitor" # only in PS 6+

    Replace or hijack existing service.
        EG.
            Set-Service -Name "wuauserv" -BinaryPathName "C:\Tools\evil.exe" 
            # Dangerous - only for lab use.


5. Advanced : WMI + CIM Service Management.
    Query full service info (with executable path)
        EG.
            Get-WmiObject -Class Win32_Service | Select-Object Name, State, StartMode, PathName

    Stop a service via WMI.
        EG.
            (Get-WmiObject -Class Win32_Service -Filter "Name='Spooler'").StopService()

    Start via CIM (modern)
        EG.
            Invoke-CimMethod -ClassName Win32_Service -MethodName StartService -Arguments @{ Name = "BITS" }


6. SECURITY / PERSISTENCE / AUDIT
    Detect suspicious autostart services
        EG.
            Get-WmiObject -Class Win32_Service | Where-Object { $_.StartMode -eq "Auto" -and $_.PathName -like "*AppData*" }

    Search for non-Microsoft services
        EG.
            Get-WmiObject Win32_Service | Where-Object { $_.PathName -notlike "*Windows*" }

    Audit all service executables
        EG
            Get-WmiObject Win32_Service | Select-Object Name, PathName | Out-File C:\Audit\services.txt


7. Writable Registry keys -> Hijack ImagePath.
    - If you have permission to modify the service registry key, you can change the path to the service executable (ImagePath) to point to your own binary.
        
        I. Find service.
            EG.
                Get-Service | Where-Object { $_.Status -eq "Stopped" }

        II. View its registry path.
            EG.
                "HKLM:\SYSTEM\CurrentControlSet\Services\$($svc.Name)"

        III. Replace the binary.
            EG.
                Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Fax" -Name "ImagePath" -Value "C:\Users\Public\reverse.exe"

        Then:
            EG.
                Start-Service Fax 
                

8. REAL-WORLD USE CASES
    Restart service if it's stuck
        EG
            $s = Get-Service "Spooler"
            if ($s.Status -ne "Running") {
                Restart-Service "Spooler"
            }
    
    Mass disable telemetry services
        EG.
            $services = "DiagTrack", "dmwappushservice"
            foreach ($svc in $services) {
                Set-Service -Name $svc -StartupType Disabled
                Stop-Service -Name $svc -Force
            }

     Dump all service configs for backup/audit
        EG
            Get-WmiObject Win32_Service | Export-Csv "C:\services_backup.csv" -NoTypeInformation

